<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
    }
    #hud div { margin-bottom: 8px; }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #aaa;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      text-shadow: 1px 1px 2px black;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="score">Score: 0</div>
  </div>
  <div id="controls">Arrow keys: Move | Space: Action | R: Restart</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three'

    // ============================================
    // GAME STATE
    // ============================================
    let score = 0
    let gameOver = false
    const keys = {}

    // ============================================
    // SCENE SETUP
    // ============================================
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(0x1a1a2e)
    scene.fog = new THREE.Fog(0x1a1a2e, 20, 50)

    // camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    )
    camera.position.set(0, 8, 12)
    camera.lookAt(0, 0, 0)

    // renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    document.body.appendChild(renderer.domElement)

    // ============================================
    // LIGHTING
    // ============================================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
    scene.add(ambientLight)

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8)
    sunLight.position.set(10, 20, 10)
    sunLight.castShadow = true
    sunLight.shadow.mapSize.width = 2048
    sunLight.shadow.mapSize.height = 2048
    scene.add(sunLight)

    // ============================================
    // GROUND
    // ============================================
    const groundGeometry = new THREE.PlaneGeometry(40, 40)
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x2d5a27,
      roughness: 0.8,
    })
    const ground = new THREE.Mesh(groundGeometry, groundMaterial)
    ground.rotation.x = -Math.PI / 2
    ground.receiveShadow = true
    scene.add(ground)

    // grid helper (optional, remove for final)
    const gridHelper = new THREE.GridHelper(40, 40, 0x444444, 0x222222)
    scene.add(gridHelper)

    // ============================================
    // PLAYER
    // ============================================
    const playerGeometry = new THREE.BoxGeometry(1, 2, 1)
    const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x4a9eff })
    const player = new THREE.Mesh(playerGeometry, playerMaterial)
    player.position.y = 1
    player.castShadow = true
    scene.add(player)

    // player physics state
    const playerState = {
      velocity: new THREE.Vector3(),
      speed: 8,
      jumpForce: 12,
      gravity: 30,
      isGrounded: true,
    }

    // ============================================
    // COLLECTIBLES
    // ============================================
    const collectibles = []

    function spawnCollectible() {
      const geometry = new THREE.SphereGeometry(0.3, 16, 16)
      const material = new THREE.MeshStandardMaterial({ 
        color: 0xffd700,
        emissive: 0xffd700,
        emissiveIntensity: 0.3,
      })
      const collectible = new THREE.Mesh(geometry, material)
      collectible.position.set(
        (Math.random() - 0.5) * 30,
        0.5,
        (Math.random() - 0.5) * 30
      )
      collectible.castShadow = true
      scene.add(collectible)
      collectibles.push(collectible)
    }

    // spawn initial collectibles
    for (let i = 0; i < 10; i++) spawnCollectible()

    // ============================================
    // INPUT
    // ============================================
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true
      
      if (e.code === 'KeyR') restart()
    })
    window.addEventListener('keyup', (e) => keys[e.code] = false)

    // ============================================
    // GAME LOGIC
    // ============================================
    function updatePlayer(delta) {
      // horizontal movement
      const moveDir = new THREE.Vector3()
      if (keys['ArrowUp'] || keys['KeyW']) moveDir.z -= 1
      if (keys['ArrowDown'] || keys['KeyS']) moveDir.z += 1
      if (keys['ArrowLeft'] || keys['KeyA']) moveDir.x -= 1
      if (keys['ArrowRight'] || keys['KeyD']) moveDir.x += 1
      
      if (moveDir.length() > 0) {
        moveDir.normalize()
        player.position.x += moveDir.x * playerState.speed * delta
        player.position.z += moveDir.z * playerState.speed * delta
      }

      // jump
      if ((keys['Space'] || keys['KeyJ']) && playerState.isGrounded) {
        playerState.velocity.y = playerState.jumpForce
        playerState.isGrounded = false
      }

      // gravity
      if (!playerState.isGrounded) {
        playerState.velocity.y -= playerState.gravity * delta
        player.position.y += playerState.velocity.y * delta
        
        if (player.position.y <= 1) {
          player.position.y = 1
          playerState.velocity.y = 0
          playerState.isGrounded = true
        }
      }

      // bounds
      player.position.x = Math.max(-19, Math.min(19, player.position.x))
      player.position.z = Math.max(-19, Math.min(19, player.position.z))
    }

    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(player)
      
      for (let i = collectibles.length - 1; i >= 0; i--) {
        const c = collectibles[i]
        const cBox = new THREE.Box3().setFromObject(c)
        
        if (playerBox.intersectsBox(cBox)) {
          scene.remove(c)
          collectibles.splice(i, 1)
          score += 10
          updateHUD()
          spawnCollectible()
        }
      }
    }

    function updateCollectibles(elapsed) {
      collectibles.forEach(c => {
        c.position.y = 0.5 + Math.sin(elapsed * 3 + c.position.x) * 0.2
        c.rotation.y = elapsed * 2
      })
    }

    // ============================================
    // HUD
    // ============================================
    function updateHUD() {
      document.getElementById('score').textContent = `Score: ${score}`
    }

    // ============================================
    // RESTART
    // ============================================
    function restart() {
      score = 0
      player.position.set(0, 1, 0)
      playerState.velocity.set(0, 0, 0)
      playerState.isGrounded = true
      
      // remove all collectibles
      collectibles.forEach(c => scene.remove(c))
      collectibles.length = 0
      
      // respawn
      for (let i = 0; i < 10; i++) spawnCollectible()
      
      updateHUD()
      gameOver = false
    }

    // ============================================
    // CAMERA FOLLOW
    // ============================================
    function updateCamera() {
      camera.position.x = player.position.x
      camera.position.z = player.position.z + 12
      camera.lookAt(player.position.x, 0, player.position.z)
    }

    // ============================================
    // GAME LOOP
    // ============================================
    const clock = new THREE.Clock()

    function animate() {
      requestAnimationFrame(animate)
      
      const delta = clock.getDelta()
      const elapsed = clock.getElapsedTime()
      
      if (!gameOver) {
        updatePlayer(delta)
        checkCollisions()
        updateCollectibles(elapsed)
        updateCamera()
      }
      
      renderer.render(scene, camera)
    }
    animate()

    // ============================================
    // RESIZE HANDLER
    // ============================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    })
  </script>
</body>
</html>
